# Introduction to embedded Linux - Buildroot

## Requirements
In order to use buildroot, we need to fulfill the requirements that are listed on the following page of the buildroot user manual: https://buildroot.org/downloads/manual/manual.html#requirement

After everything is installed properly, we need to download the buildroot github repository: https://github.com/buildroot/buildroot.git

## Usage
If you want to generate a linux image with buildroot for a dedicated chip, you can look at the `./buildroot/configs` folder, if your chip is already there. If not, you might find it by googleing for it on the internet.

## Building the image
+ Create the `.config` file that defines the build environment for the specific chip. In case of the STM32MP1, we type `$ make stm32mp157a_dk1_defconfig` at the root of the buildroot repository
	- *Caution*: `stm32mp157a_dk1_defconfig` is the exact same name as the file for our chip within the `configs` folder. You might need to place your targeted config file (as well as all other needed files that come with you googled result if buildroot supports your chip not by default) to the individual folder (e.g. the `configs` folder for the config file)
+ Now we are able to call the _menuconfig_ program of buildroot, which enables us to choose which kernel options, libraries, frameworks, kernel patches, etc. should be compiled to our linux image that will be generated by buildroot.
	- Type `$ make menuconfig` to start the ncurses application and choose the required packages, patches, libraries, etc.
+ After the menuconfig has been saved and you exited the menuconfig application, we can type `$ make` within the root folder of the buildroot repository to compile your custom linux image
	- *CAUTION*: This might take a few hours!

## Using the buildroot linux image
+ After we build our custom linux image (in case the build process has finished without any errors), it can be found within the folder `/path/to/buildroot/output/images/*`.

+ Now we can flash the image by using `$ sudo dd if=`/path/to/buildroot/output/images/sdcard.img of=/dev/mmcblk2`
	- *CAUTION*: dd will do a bit-by-bit copy. So it does not matter what was on the SD card before. Be careful with dd, since it can damage your system very badly, if you have a type and bit-copy to your hosts disk!
	- Look out for the correct device with `$ lsblk`
	- Make sure to unmount the SD card before flashing!

## Development approach
+ I recommend to use the basic/minimal buildroot configuration from the default configurations within `./configs` of the buildroot repository or the buildroot configuration that you downloaded from the internet. If you managed to compile it successfully, you can gradually add new features within the `$ make menuconfig` user interface of buildroot.
	- After an adjustment of the menuconfig configuration, only the newly added features of your image will be build! The already successfully created parts of the linux image will not be recompiled, so it won't take as much time to compile as it needed for the first buildroot build!
+ If you want to add your own applications (either as binary or as scripts), you need to place the files within the buildroot repository under `./boards/<manufacturer>/<chip>/overlay` (e.g. `./buildroot/board/stmicroelectronics/stm32mp157a-dk1/overlay`)
	- *CAUTION*: You can only recreate paths (aka folders) under the `overlay` folder of the already existing root-filesystem and place your application files there!
	- After you added you files, you can call `$ make` to create an image with your files added
	- If you want to add new paths to the root-filesystem, you need to go deeper into the buildroot documentation

## UART/RS232 console
+ To get access to your embedded device via a terminal, the most SOCs (System On Chip) have a UART interface. UART stands for _universal asynchonous receiver tansmitter_ and is an periferal on a controller that is able to send and receive data asynchronously and that the user can adust to different baudrates, number of databits per message, endianess, etc.
	- Most of the time, the controller implements a RS232 communication standart over the UART periferal.
+ RS232 defines a protocol how to start and end messages over a serial communication but not how many data bits are used!
+ Most commonly, we talk about UART and mean UART with 8 bits of data that implements a RS232 standart, since the extended ASCII standart takes 8 bit per character.
	- Programs like minicom interprets the data over the serial communication as ASCII and also sends data as ASCII to the UART interface
+ Software like Arm-Trusted-Firmware, U-Boot and the linux kernel can be configured to send boot logs or a terminal interface to a defined UART interface that is configured as an ASCII sender and receiver
	- Under linux, we have a device file for the UART interfaces that are available and the one that is configured as described above needs to be configured as the UART terminal console for the linux kernel.
+ The UART periferial is defined within the device tree for our SOC

+ U-Boot, Arm-Trusted-Firmware and the linux kernel know where the correctly configured UART periferial is and then write their terminal interface there.
	- Under linux, we have a device file for it
+ Programs like minicom, screen, etc. are setting up a UART interface on the (debugging-)machine with the correct baudrate to your SOC and with 8 bits of data and enable us to read and write to the device file via one interface (instead of separatly read and write via echo and cat to the device file. Also echo and cat are not able to set the baudrate correctly within any further system configuration!)  

### UART references
+ http://www.simplyembedded.org/tutorials/msp430-uart/ --> Very good overview
+ https://unix.stackexchange.com/questions/22545/how-to-connect-to-a-serial-port-as-simple-as-using-ssh --> Communication with minicom explained 1
+ https://unix.stackexchange.com/questions/226077/linux-uart-io-file --> Communication with minicom explained 2
+ https://www.digi.com/support/knowledge-base/how-to-disable-serial-console-in-linux-to-allow-ap --> Disable UART for linux
+ https://man7.org/linux/man-pages/man4/ttys.4.html 
+ https://wiki.archlinux.org/title/working_with_the_serial_console
